
#' @export
#' Adaptive Importance Sampling (LAIS).
#'
#' \code{lais} returns samples and the associated weights generated by LAIS.
#' \code{apis} returns samples and the associated weights generated by APIS.
#' \code{pmc} returns samples and the associated weights generated by PMC.
#'
#' These functions perform adaptive important sampling. They are the implementation of 3 methods: Layered Adaptive Importance Sampling (LAIS),
#' Adaptive Population Importance Sampling (APIS) and Population Monte Carlo (PMC). Theses 3 implementations follwos the same steps:
#' \enumerate{
#'   \item the adaptation step where a set of N proposal distribution are update at each iteration t for t=1,...,T.
#'   \item the sampling step where M samples are drawn for each of the TxN proposal.
#'   \item the weighting step wheare all TxNxM samples are given a weight.
#' }
#' 
#' In these 3 implementations, the proposal distributions for are multivariate gaussian distributions with independent marginals. 
#' The covariance matrix of theses proposal distribution are equal and provided by the user (atgument \code{sig2_prop}). 
#' The location parameters of the proposal distributions are initialized by the user
#' and are then updated at each iteration t of the adaptation step. 
#' The three methods implemented  here only differ by the way
#' the location parameters \eqn(mu{t, n}) (\eqn(t = 1,..., T) and \eqn(n = 1, ..., N)) of the proposal are updated.
#' \itemize{
#'   \item \code{lais} uses a Markov chain Monte Carlo with the Metropolis-Hasting algorithm. 
#'   \item \code{apis} takes, as a new location parameter\eqn(mu_{t,n}),
#'   1 of the M samples drawn from the proposal distribution with location parameter mu_{t-1,n}). 
#'   Each sample has a different probability of being chosen.
#'   This probability depends on the weight given by important sampling that is performed only with this proposal distribution.
#'   \item \code{apis} takes, as location parameter \eqn(mu_{t,n}),
#'   the weighted mean of M samples drawn from a the  proposal distribution with location parameter \eqn(mu_{t-1,n}).
#'   Each sample has a different probability of being chosen.
#'   The weight of each sample is given by important sampling that is performed only with this proposal distribution.
#' }
#' 
#' The weighting step can be performed in different way depending on how we considered the samples drawn at the sampling step
#' 
#' @param logposterior A function taking as input a vector of length d. It corresponds to the log-posterior likehood of the distrubution one wants to simulate from.
#' @param d  An integer indicating the number of dimension of the logposterior.
#' @param N An integer indicating the number of chains used for the adaptation.
#' @param T An integer indicating the length of the chains used for the adaptation.
#' @param M An integer indicating the numbers of draws to be made for each proposals.
#' @param mu A numerical matrix of dimension d x N used to initialized the location parameters of the N proposal chains.
#' @param sigma A numerical vector of length d indicating the standard deviation to be used for each dimension of the gaussian proposal (each dimension is drawn independently)
#' @param sigma_mh A numerical vector of length d indicating the standard deviation to be used for each dimension of the proposal used in the MH step (only for the lais function). By default, it is equal to sigma.
#' @param compute_denom A function that indicates how to compute denominators used to compute the weights. By default, compute_denomtable_byrow is used where the denominator for one drawn sample x_t,m,n is computed as mixture of the N proposals at time t.
#' @param reuse_weights a boolean indicating whether to reuse the weight computed in the adaptive steps for the importance sampling step. For lais, the weight in the a
#' @return a list with the following elements. 
##' \itemize{
##'  \item{"x"}{an array of dimension T x d x M x N containing the samples drawn from LAIS.}
##'  \item{"mu"}{an array of dimension T x d x N containing the location parameters of the poposal distribution used in the importance sampling step.}
##'  \item{"weights"}{an array of dimension T x M x N containing the unormalized weights associated with the samples in x.}
##'  \item{"pi"}{an array of dimension T x M x N the loglikelihood evaluated for each sample drawn in x.} 
##'  \item{"denom"}{an array of dimension T x M x N the denominators of the weight for each sample drawn in x.} 
##'  \item{"marglik"}{an estimation of the marginal likelihood.}
##' }
#' @examples
#' # draw samples from the distribution defined by the loglikelihood lposterior_3 which is a mixture of two gaussians of dimension 2.
#' lais_chain <- lais(logposterior = lposterior_3  d = 2, N = 20, T = 100, M = 5, mu = rnorm(40, sd = 5), sigma = rep(sqrt(13), 2), sigma_mh = rep(5, 2), compute_denom = compute_denomtable_byrow)
#' # estimate the expected value of the distribution given by lposterior_3 (the real expected value is [2.5, 8]
#' compute_expectation(lais_chain$x, lais_chain$w)
#' \dontrun{
#' # Similar example with a mixture of 5 gaussians. the real expected value is [1.6, 1.4]
#' lais_chain <- lais(logposterior = lposterior_1,  d = 2, N = 100, T = 100, M = 10, mu = rnorm(100, sd = 5), sigma = rep(sqrt(13), 2), sigma_mh = rep(5, 2), compute_denom = compute_denomtable_byrow)
#' compute_expectation(lais_chain$x, lais_chain$w)
#' }

create_adaptive_is <- function(gen_mu_chains){
  ais <- function(logposterior,
                  mu, sig2_adapt = sig2_prop, sig2_prop,
                  compute_denom_table = compute_denom_table_byrow_rcpp,
                  N = 10, T = 100, M = 2)
  {
    mu_chains <-
      gen_mu_chains(logposterior = logposterior,
                               mu = mu, sigma = sig2_adapt,
                               T = T, N = N, M = M)
    is_step <- 
      importance_sampling(logposterior = logposterior,
                          mu_chains = mu_chains,
                          sigma2 = sig2_prop,
                          compute_denom_table = compute_denom_table,
                          T = T, N = N, M = M)
    ais_res <- c(list("mu" = mu_chains), is_step)
    return(ais_res)
  }
}
pmc <- create_adaptive_is(gen_mu_chains_pmc)
apis <- create_adaptive_is(gen_mu_chains_apis)


lais <- function(logposterior,
                mu, sig2_adapt = sig2_prop, sig2_prop,
                compute_denom_table = compute_denom_table_byrow_rcpp,
                T = 100,  N = 2, M = 2)
{
  mu_chains <-
    gen_mu_chains_mcmc(logposterior = logposterior,
                       mu = mu, sigma2 = sig2_adapt,
                       T = T, N = N)
  is_step <- 
    importance_sampling(logposterior = logposterior,
                        mu_chains = mu_chains,
                        sigma2 = sig2_prop,
                        compute_denom_table = compute_denom_table,
                        T = T, N = N, M = M)
  ais_res <- c(list("mu" = mu_chains), is_step)
  invisible(ais_res)
}

importance_sampling <-
  function(logposterior,
           mu_chains,
           sigma2,
           compute_denom_table = compute_denom_table_byrow_rcpp,
           T = 100, N = 2, M = 2)
  {
    D = dim(mu_chains)[1]
    xs_chain <-
      gen_xs_rcpp(mu = mu_chains, sigma2 = sigma2,
                  D = D, T = T, N = N, M = M)
    loglik_table <-
      compute_loglik_table(logposterior = logposterior,
                           x = xs_chain,
                           D = D, T = T, N = N, M = M)
    message("Computing denominator table:")
    denom_table <-
      compute_denom_table(x = xs_chain,
                         mu = mu_chains,
                         sigma2 = sigma2,
                         D = D, T = T, N = N, M = M)
    weight_table <-
      compute_weight_table(loglik_table = loglik_table,
                           denom_table = denom_table)
    is_res <- list("x" = xs_chain,
                   "loglik" = loglik_table,
                   "denom" = denom_table,
                   "weight" = weight_table)
    return(is_res)
  }

