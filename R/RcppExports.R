# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

simple_MH_rcpp <- function(lp, mu, sigma2, T = 100L) {
    .Call('_AISamplR_simple_MH_rcpp', PACKAGE = 'AISamplR', lp, mu, sigma2, T)
}

gen_xs_rcpp <- function(mu, sigma2, D, T, N, M) {
    .Call('_AISamplR_gen_xs_rcpp', PACKAGE = 'AISamplR', mu, sigma2, D, T, N, M)
}

compute_loglik_table_rcpp <- function(lp, x, D, T, N, M) {
    .Call('_AISamplR_compute_loglik_table_rcpp', PACKAGE = 'AISamplR', lp, x, D, T, N, M)
}

#' @rdname compute_logdenom_bytable
#' @export
compute_logdenom_bybox <- function(x, mu, sigma2, D, T, N, M) {
    .Call('_AISamplR_compute_logdenom_bybox_rcpp', PACKAGE = 'AISamplR', x, mu, sigma2, D, T, N, M)
}

#' @rdname compute_logdenom_bytable
#' @export
compute_logdenom_byrow <- function(x, mu, sigma2, D, T, N, M) {
    .Call('_AISamplR_compute_logdenom_byrow_rcpp', PACKAGE = 'AISamplR', x, mu, sigma2, D, T, N, M)
}

#' Computes the logarithm of the denominator of importance sampling weights.
#' 
#' \code{compute_logdenom_bybox}}, \code{compute_logdenom_byrow}
#' and \code{compute_logdenom_bytable}
#' offers three different ways to compute 
#' the logarithm of the denominator of the importance sampling weights.
#' 
#' The weighting step can be performed in different ways depending on 
#' how we considere the samples drawn at the sampling step.
#' We can think that one sample was drawn from its own corresponding proposal distribution 
#' or that one sample was drawn from a mixture of proposal distributions. 
#' In this package, three methods to compute the denominator of the weights are available:
#' \itemize{
#'   \item \code{compute_logdenom_bybox} 
#'   where we considered that a sample x_\{t,n,m\} 
#'   is drawn from an unique 
#'   proposal distribution with location parameter mu_\{t,n\}.
#'   \item \code{compute_logdenom_byrow} 
#'   where we considered that a sample  x_\{t,n,m\} 
#'   is drawn from an equiprobable mixture
#'   of all proposal distributions at time t.
#'   \item \code{compute_logdenom_bytable} 
#'   where we considered that a sample x_\{t,n,m\} 
#'   is drawn from an equiprobable mixture
#'   of all available proposal distributions, for all times t = 1,..., T and 
#'   chains of proposal n = 1,..., N.
#' }
#' 
#' @param x A numerical array of dimension D x T x N x M. 
#' It is the result of the sampling step in the adapative importance sampling scheme.
#' @param mu A numerical array of dimension D x T x N.
#' It is the result of the adaptaion step in the adapative importance sampling scheme.
#' @param sigma2  A numerical matrix of length D.
#' It provides the variance of each dimension of the gaussian proposal distribution
#' used in the sampling step.
#' @param D  An integer providing the dimension of the input space.
#' @param T  An integer providing the number iterations used in the adaptation step.
#' @param N  An integer providing the number of proposal distribution chains used.
#' @param M  An integer providing the number of samples drawn from each proposal.
#' 
#' @return An array of dimension T x N x M with the logarithm of the 
#' denominator needed to compute the importance sampling weights.
#' 
#' @examples
#' D <- 1
#' T <- 10
#' N <- 2
#' M <- 3
#' lpexp <- function(x){
#'   dexp(x, log = TRUE)
#' }
#' 
#' # Generates weighted samples for the exponential law
#' pmc_lpexp_r <- pmc(lpexp,
#'    mu = matrix(rnorm(D*N, mean = 1, sd = 1), nrow = D, ncol = N),
#'    sig2_adapt = rep(1, D), sig2_samp = rep(1, D),
#'    compute_logdenom = compute_logdenom_byrow,
#'    N = N, T = T, M = M)
#' with(pmc_lpexp_r, plot(x  = x, y = weight))
#' # theorical value: ~ [1]
#' with(pmc_lpexp_r, compute_expectation(x, weight)) 
#' 
#' # Recompute the denominator
#' # with one gaussian proposal distribution associated to each sample.
#' logdenom_bybox <- 
#'   with(pmc_lpexp_r,
#'        compute_logdenom_bybox(x = x, mu = mu, sigma2 = 1,
#'                               D = D, T = T, N = N, M = M)
#'   )
#' # Plot new weights associated to each sample
#' with(pmc_lpexp_r, plot(x  = x, y = exp(loglik - logdenom_bybox)))
#' # Estimate expectation with the new weights
#' with(pmc_lpexp_r,
#'      compute_expectation(x  = x,
#'                          weight = exp(loglik - logdenom_bybox))
#' )
#' 
#' # Recompute the denominator
#' # with a proposal distribution which is a mixture of
#' # the N gaussian proposal distribution at time t.
#' logdenom_byrow <- 
#'  with(pmc_lpexp_r,
#'           compute_logdenom_byrow(x = x, mu = mu, sigma2 = 1,
#'                                  D = D, T = T, N = N, M = M)
#'  )
#' # Plot new weights associated to each sample
#' with(pmc_lpexp_r, plot(x  = x, y = exp(loglik - logdenom_byrow)))
#' # Estimate expectation with the new weights
#' with(pmc_lpexp_r,
#'      compute_expectation(x  = x,
#'                          weight = exp(loglik - logdenom_byrow))
#' )
#' 
#' # Recompute the denominator
#' # with a proposal distribution which is a mixture of
#' # the T x N gaussian proposal distribution available.
#' logdenom_bytable <- 
#'   with(pmc_lpexp_r,
#'        compute_logdenom_bytable(x = x, mu = mu, sigma2 = 1,
#'                                 D = D, T = T, N = N, M = M)
#'   )
#' # Plot new weights associated to each sample
#' with(pmc_lpexp_r, plot(x  = x, y = exp(loglik - logdenom_bytable)))
#' # Estimate expectation with the new weights
#' with(pmc_lpexp_r,
#'      compute_expectation(x  = x,
#'                          weight = exp(loglik - logdenom_bytable))
#' )
#' 
#' @export
compute_logdenom_bytable <- function(x, mu, sigma2, D, T, N, M) {
    .Call('_AISamplR_compute_logdenom_bytable_rcpp', PACKAGE = 'AISamplR', x, mu, sigma2, D, T, N, M)
}

gen_mu_chain_apis_rcpp <- function(lp, mu, sigma2, T, M) {
    .Call('_AISamplR_gen_mu_chain_apis_rcpp', PACKAGE = 'AISamplR', lp, mu, sigma2, T, M)
}

gen_mu_chain_pmc_rcpp <- function(lp, mu, sigma2, T, M) {
    .Call('_AISamplR_gen_mu_chain_pmc_rcpp', PACKAGE = 'AISamplR', lp, mu, sigma2, T, M)
}

