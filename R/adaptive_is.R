compute_nextmu_apis <- function(xmat, weights){
  #apply(sweep(xmat, 2, weights, "*"), 1, sum)
  apply(xmat, 1, weighted.mean, w = weights)
}

compute_nextmu_pmc <- function(xmat, weights){
  if(any(is.na(weights))) browser()
  xmat[, rmultinom(1, 1, weights)]
}

# better to create a function compute_ais_weights(obj, compute_denom, reuse_weight)
compute_ais_weights <- function(pchain, sigma, compute_denom, reuse_weights){
  if(reuse_weights & !is.null(pchain$denom)) denom_arr <- pchain$denom
  else denom_arr <- compute_denom(pchain$x, pchain$mu, sigma)
  weights <- compute_weights(pchain$pi, denom_arr)
  list(x = pchain$x, mu = pchain$mu, w = weights, pi = pchain$pi, denom = denom_arr, marglik = mean(weights))
}

create_adaptive_is <- function(parallel_chain){
  adaptive_is <- function(logposterior, d, N = 10, T = 100, M = 2, mu, sigma, compute_denom = compute_denomtable_byrow, reuse_weights = FALSE, ...){
    pchain <- parallel_chain(d = d, N = N, T = T, M = M, mu = mu, sigma = sigma, logposterior = logposterior)
   compute_ais_weights(pchain, sigma, compute_denom, reuse_weights)
  }
}

#' @export
#' Layered Adaptive Importance Sampling (LAIS).
#'
#' \code{lais} returns samples and the associated weights generated by LAIS.
#'
#' This function performs adaptive important sampling using the method Layered Adaptive Importance Sampling (LAIS). New location parameters for the proposal distributions are provided by a Metripolis-Hasting (MH) step. The proposal distribution are gaussians the means of which are given by the MH step used for adaptation.
#'
#' @param logposterior A function taking as input a vector of length d. It corresponds to the log-posterior likehood of the distrubution one wants to simulate from.
#' @param d  An integer indicating the number of dimension of the logposterior.
#' @param N An integer indicating the number of chains used for the adaptation.
#' @param T An integer indicating the length of the chains used for the adaptation.
#' @param M An integer indicating the numbers of draws to be made for each proposals.
#' @param mu A numerical matrix of dimension d x N used to initialized the location parameters of the N proposal chains.
#' @param sigma A numerical vector of length d indicating the standard deviation to be used for each dimension of the gaussian proposal (each dimension is drawn independently)
#' @param sigma_mh A numerical vector of length d indicating the standard deviation to be used for each dimension of the proposal used in the MH step (only for the lais function). By default, it is equal to sigma.
#' @param compute_denom A function that indicates how to compute denominators used to compute the weights. By default, compute_denomtable_byrow is used where the denominator for one drawn sample x_t,m,n is computed as mixture of the N proposals at time t.
#' @param reuse_weights a boolean indicating whether to reuse the weight computed in the adaptive steps for the importance sampling step. For lais, the weight in the a
#' @return mu A numerical matrix of dimensionyy d x N used to initialized the location parameters of the N proposal chains.
#'
#'   will be an integer. If integer overflow
#'   \url{http://en.wikipedia.org/wiki/Integer_overflow} occurs, the output
#'   will be NA with a warning. Otherwise it will be a length-one numeric or
#'   complex vector.
#'
#'   Zero-length vectors have sum 0 by definition. See
#'   \url{http://en.wikipedia.org/wiki/Empty_sum} for more details.
#' @examples
#' sum(1:10)
#' sum(1:5, 6:10)
#' sum(F, F, F, T, T)
#'
#' sum(.Machine$integer.max, 1L)
#' sum(.Machine$integer.max, 1)
#'
#' \dontrun{
#' sum("a")
#' }
lais <- create_adaptive_is(indep_chains_mcmc)
lais <- function(logposterior, d, N = 10, T = 100, M = 2, mu, sigma, sigma_mh = sigma, compute_denom = compute_denomtable_byrow, reuse_weights = FALSE){
    pchain <- indep_chains_mcmc(logposterior = logposterior, d = d, N = N, T = T, M = M, mu = mu, sigma = sigma, sigma_mh = sigma_mh)
    compute_ais_weights(pchain, sigma, compute_denom, reuse_weights = FALSE)
}
indep_apis <- create_adaptive_is(indep_chains_apis)
indep_pmc <- create_adaptive_is(indep_chains_pmc)
apis <- create_adaptive_is(fchain_apis )
pmc <- create_adaptive_is(fchain_pmc)


